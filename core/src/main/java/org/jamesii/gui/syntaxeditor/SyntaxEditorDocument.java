/*
 * The general modelling and simulation framework JAMES II.
 * Copyright by the University of Rostock.
 * 
 * LICENCE: JAMESLIC
 */
package org.jamesii.gui.syntaxeditor;

import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.PlainDocument;

import org.jamesii.SimSystem;

/**
 * The class represents the document used by the {@link SyntaxEditorKit}. It
 * basically keeps track of changes to the document and invokes a reparsing if
 * needed and so on. It also retrieves the tokens generated by the lexer and
 * makes it accessible to the {@link SyntaxEditorView} for highlighting
 * purposes.
 * 
 * @author Stefan Rybacki
 * 
 * @see SyntaxEditorView
 * @see SyntaxEditorKit
 * @see ILexer
 * @see ILexerToken
 * 
 */
class SyntaxEditorDocument extends PlainDocument {
  /**
   * Serialization ID
   */
  private static final long serialVersionUID = 468658674777321682L;

  /**
   * the lexer used for parsing the document
   */
  private ILexer lexer;

  /**
   * copy of syntax tokens provided by lexer
   */
  private List<ILexerToken> syntaxTokens = new ArrayList<>();

  /**
   * continuous timer for background parsing if no update occurs
   */
  private Timer timer;

  /**
   * holds the time in ms when the last update happened
   */
  private long lastUpdate;

  /**
   * flag indicating whether there was an update since the last parsing
   */
  private boolean updated = false;

  /**
   * delay that need to pass until parsing starts after update
   */
  private static final int parsingDelay = 250;

  /**
   * creates a new {@link SyntaxEditorDocument} using the specified lexer
   * 
   * @param lexer
   *          the lexer for this document
   * 
   */
  public SyntaxEditorDocument(ILexer lexer) {
    super();
    this.lexer = lexer;
    putProperty(PlainDocument.tabSizeAttribute, Integer.valueOf(4));

    addDocumentListener(new DocumentListener() {

      @Override
      public void changedUpdate(DocumentEvent e) {
      }

      @Override
      public void insertUpdate(DocumentEvent e) {
        updated();

        // shift syntax and problem tokens according to offs and str.length()
        LexerTokenUtils.moveTokensAfterInsert(syntaxTokens, e.getOffset(),
            e.getLength());
      }

      @Override
      public void removeUpdate(DocumentEvent e) {
        updated();

        // shift syntax and problem tokens according to offs and len
        LexerTokenUtils.moveTokensAfterRemove(syntaxTokens, e.getOffset(),
            e.getLength());
      }

    });

    // start timer for continuous parsing
    timer = new Timer(true);
    timer.scheduleAtFixedRate(new TimerTask() {
      @Override
      public void run() {
        if (isUpdated()
            && System.currentTimeMillis() - lastUpdate > parsingDelay) {
          try {
            parse();
            if (!isUpdated()) {
              fireChangedUpdate(new DefaultDocumentEvent(0, getLength(),
                  DocumentEvent.EventType.CHANGE));
            }
          } catch (BadLocationException e) {
            SimSystem.report(e);
          }
        }
      }
    }, 5, parsingDelay);
  }

  /**
   * @return true if {@link #updated} is true, false else
   */
  private synchronized boolean isUpdated() {
    return updated;
  }

  /**
   * helper method to mark the document as updated
   */
  private synchronized void updated() {
    lastUpdate = System.currentTimeMillis();
    updated = true;
  }

  /**
   * Invokes the lexer's parse method for the document on document changes as
   * well as updates the token lists.
   * 
   * @throws BadLocationException
   */
  public synchronized void parse() throws BadLocationException {
    lexer.stopParsing();
    updated = false;

    Reader input = new DocumentReader(this);

    lexer.parse(input);

    try {
      input.close();
    } catch (IOException e) {
      SimSystem.report(e);
    }

    // copy syntax and problem tokens
    syntaxTokens = new ArrayList<>();

    syntaxTokens.addAll(lexer.getSyntaxTokens());
  }

  /**
   * @return the maximum line count for the current document
   */
  public int getMaxLines() {
    return getEndPosition().getOffset();
  }

  /**
   * @return syntax tokens cached within the document until reparse
   */
  public synchronized List<? extends ILexerToken> getSyntaxTokens() {
    return syntaxTokens;
  }

  /**
   * @param lexer
   *          the lexer to set
   */
  public synchronized void setLexer(ILexer lexer) {
    this.lexer = lexer;
    try {
      parse();
    } catch (BadLocationException e) {
      SimSystem.report(e);
    }
  }

}
