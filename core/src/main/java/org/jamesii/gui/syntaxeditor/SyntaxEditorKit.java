/*
 * The general modelling and simulation framework JAMES II.
 * Copyright by the University of Rostock.
 * 
 * LICENCE: JAMESLIC
 */
package org.jamesii.gui.syntaxeditor;

import java.awt.Font;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JEditorPane;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentEvent.EventType;
import javax.swing.event.DocumentListener;
import javax.swing.text.DefaultEditorKit;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.View;
import javax.swing.text.ViewFactory;

import org.jamesii.gui.utils.BasicUtilities;

/**
 * Main class to support syntax highlighting in the {@link JEditorPane}. Just
 * create an instance using the right generic parameters and pass it to the
 * JEditorPane using
 * {@link JEditorPane#setEditorKit(javax.swing.text.EditorKit)}.
 * <p>
 * What are the right parameters?
 * <p>
 * 1. The {@code SyntaxTokenType} should identify a class or type that can
 * identify syntax token states e.g. this token is a STRING or a COMMENT 2. The
 * {@code ProblemTokenType} should identify a class or type that can identify
 * problem token states e.g. this token is an ERROR or WARNING
 * <p>
 * The same Types are used when passing an appropriate lexer as well as
 * appropriate token stylizers.
 * 
 * @see ILexerTokenStylizer
 * @see ILexer
 * 
 * @author Stefan Rybacki
 * 
 */
class SyntaxEditorKit extends DefaultEditorKit implements ViewFactory,
    DocumentListener, PropertyChangeListener, IInfoProviderListener {
  /**
   * Serialization ID
   */
  private static final long serialVersionUID = -7751986842989656089L;

  /**
   * default font used in editor
   */
  public static final Font DEFAULT_FONT = new Font(Font.MONOSPACED, Font.PLAIN,
      12);

  /**
   * the lexer used to parse the document to highlight
   */
  private ILexer lexer;

  /**
   * the stylizer for the syntax tokens generated by the lexer
   */
  private ILexerTokenStylizer<ILexerToken> syntaxStylizer;

  /**
   * The {@link JEditorPane} this kit is attached to
   */
  private JEditorPane editorPane;

  /**
   * stores the document utilized by this kit
   */
  private SyntaxEditorDocument document;

  /**
   * the undo redo manger
   */
  private JamesUndoManager undoManager = new JamesUndoManager();

  /**
   * The list of registered information providers.
   */
  private final List<IInfoProvider> providers = new ArrayList<>();

  /**
   * Creates a new {@link SyntaxEditorKit} that can be used to support lexer
   * based syntax highlighting in a {@link JEditorPane}
   * 
   * @param lexer
   *          the lexer that generates the needed tokens that are being
   *          highlighted
   * @param syntaxStylizer
   *          the stylizer responsible for the color and font style choice for
   *          each syntax token
   */
  public SyntaxEditorKit(ILexer lexer,
      ILexerTokenStylizer<ILexerToken> syntaxStylizer) {
    super();
    setHighlighting(lexer, syntaxStylizer);
  }

  @Override
  public View create(Element elem) {
    return new SyntaxEditorView(elem, this);
  }

  @Override
  public ViewFactory getViewFactory() {
    return this;
  }

  /**
   * Forwards the syntax tokens from the assigned {@link SyntaxEditorDocument}.
   * 
   * @return the syntax tokens for the assigned document
   */
  public List<? extends ILexerToken> getSyntaxTokens() {
    return document.getSyntaxTokens();
  }

  @Override
  public Document createDefaultDocument() {
    document = new SyntaxEditorDocument(lexer);
    document.addDocumentListener(this);
    document.addUndoableEditListener(undoManager);
    return document;
  }

  @Override
  public void install(JEditorPane c) {
    editorPane = c;
    editorPane.setFont(DEFAULT_FONT);

    editorPane.addPropertyChangeListener(this);
    super.install(editorPane);

  }

  @Override
  public void changedUpdate(DocumentEvent e) {
    BasicUtilities.invokeLaterOnEDT(new Runnable() {
      @Override
      public void run() {
        editorPane.repaint();
      }
    });
  }

  @Override
  public void insertUpdate(DocumentEvent e) {
  }

  @Override
  public void removeUpdate(DocumentEvent e) {
  }

  @Override
  public void propertyChange(PropertyChangeEvent evt) {
    if (evt.getPropertyName().equals("document")) {
      ((Document) evt.getOldValue()).removeDocumentListener(this);
      ((Document) evt.getNewValue()).addDocumentListener(this);

      ((Document) evt.getOldValue()).removeUndoableEditListener(undoManager);
      undoManager.discardAllEdits();
      undoManager.die();
      undoManager.end();

      undoManager = new JamesUndoManager();
      ((Document) evt.getNewValue()).addUndoableEditListener(undoManager);

      if (evt.getNewValue() instanceof SyntaxEditorDocument) {
        document = ((SyntaxEditorDocument) evt.getNewValue());
      } else {
        throw new IllegalArgumentException(
            "document must be a SyntaxEditorDocument!");
      }
    }
  }

  /**
   * @return the undo manager for this kit
   */
  public final JamesUndoManager getUndoManager() {
    return undoManager;
  }

  /**
   * Sets the highlighting for the currently assigned
   * {@link SyntaxEditorDocument} using the given {@link ILexer} and
   * {@link ILexerTokenStylizer}s.
   * 
   * @param lexer
   *          the lexer to use
   * @param syntaxStylizer
   *          the stylizer for syntax tokens
   */
  public final void setHighlighting(ILexer lexer,
      ILexerTokenStylizer<ILexerToken> syntaxStylizer) {
    this.lexer = lexer;
    this.syntaxStylizer = syntaxStylizer;
    if (document != null) {
      document.setLexer(lexer);
    }
  }

  /**
   * @return the stylizer for syntax tokens
   */
  public ILexerTokenStylizer<ILexerToken> getSyntaxStylizer() {
    return syntaxStylizer;
  }

  /**
   * Adds an information provider.
   * 
   * @param provider
   *          the provider to add
   */
  public void addInfoProvider(IInfoProvider provider) {
    if (provider != null && !providers.contains(provider)) {
      providers.add(provider);
      provider.addInfoProviderListener(this);
      for (DocumentListener l : document.getDocumentListeners()) {
        if (l != null) {
          l.changedUpdate(document.new DefaultDocumentEvent(0, 0,
              EventType.CHANGE));
        }
      }
    }
  }

  /**
   * Removes a registered information provider.
   * 
   * @param provider
   *          the provider to remove
   */
  public void removeInfoProvider(IInfoProvider provider) {
    if (provider != null) {
      provider.removeInfoProviderListener(this);
    }
    providers.remove(provider);
  }

  @Override
  public void tokenInserted(IInfoProvider provider, int tokeIndex) {
    tokensChanged(provider);
  }

  @Override
  public void tokenRemoved(IInfoProvider provider, int tokenIndex) {
    tokensChanged(provider);
  }

  @Override
  public void tokensChanged(IInfoProvider provider) {
    if (providers.contains(provider)) {
      BasicUtilities.invokeLaterOnEDT(new Runnable() {

        @Override
        public void run() {
          editorPane.repaint();
        }

      });
    }
  }

  /**
   * Gets the registered information providers.
   * 
   * @return the registered information providers
   */
  public Iterable<IInfoProvider> getInfoProviders() {
    return providers;
  }

}
