/*
 * The general modelling and simulation framework JAMES II.
 * Copyright by the University of Rostock.
 * 
 * LICENCE: JAMESLIC
 */
package org.jamesii.simspex.adaptiverunner.analysis;


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.jamesii.core.util.misc.Pair;
import org.jamesii.core.util.misc.Strings;
import org.jamesii.simspex.adaptiverunner.SimplePolicyObserver;
import org.jamesii.simspex.adaptiverunner.policies.BiasedRandomSelection;
import org.jamesii.simspex.adaptiverunner.policies.EpsilonDecreasing;
import org.jamesii.simspex.adaptiverunner.policies.EpsilonDecreasingMix;
import org.jamesii.simspex.adaptiverunner.policies.EpsilonFirst;
import org.jamesii.simspex.adaptiverunner.policies.EpsilonGreedy;
import org.jamesii.simspex.adaptiverunner.policies.EpsilonGreedyDecrInit;
import org.jamesii.simspex.adaptiverunner.policies.EpsilonGreedyDecreasing;
import org.jamesii.simspex.adaptiverunner.policies.EpsilonLeastTaken;
import org.jamesii.simspex.adaptiverunner.policies.IntEstim;
import org.jamesii.simspex.adaptiverunner.policies.IntEstimDec;
import org.jamesii.simspex.adaptiverunner.policies.Pursuit;
import org.jamesii.simspex.adaptiverunner.policies.RandomSelection;
import org.jamesii.simspex.adaptiverunner.policies.RewardComparison;
import org.jamesii.simspex.adaptiverunner.policies.SoftMax;
import org.jamesii.simspex.adaptiverunner.policies.SoftMaxDecreasing;
import org.jamesii.simspex.adaptiverunner.policies.SoftMaxDecreasingMix;
import org.jamesii.simspex.adaptiverunner.policies.UCB1;
import org.jamesii.simspex.adaptiverunner.policies.UCB1Tuned;
import org.jamesii.simspex.adaptiverunner.policies.UCB2;
import org.jamesii.simspex.adaptiverunner.policies.plugintype.IMinBanditPolicy;


/**
 * Simple analysis code to present the results of the log files generated by
 * {@link SimplePolicyObserver} more conveniently.
 * 
 * @author Roland Ewald
 * 
 */
public class ResultsAnalysis {

  /**
   * The names of the policies to be considered.
   */
  // TODO query these from registry
  public static final String[] POLICY_NAMES =
      { Strings.dispClassName(BiasedRandomSelection.class),
          Strings.dispClassName(EpsilonGreedy.class),
          Strings.dispClassName(EpsilonGreedyDecreasing.class),
          Strings.dispClassName(EpsilonDecreasing.class),
          Strings.dispClassName(EpsilonDecreasingMix.class),
          Strings.dispClassName(EpsilonGreedyDecrInit.class),
          Strings.dispClassName(EpsilonFirst.class),
          Strings.dispClassName(EpsilonLeastTaken.class),
          Strings.dispClassName(IntEstim.class),
          Strings.dispClassName(IntEstimDec.class),
          Strings.dispClassName(Pursuit.class),
          Strings.dispClassName(RandomSelection.class),
          Strings.dispClassName(RewardComparison.class),
          Strings.dispClassName(SoftMax.class),
          Strings.dispClassName(SoftMaxDecreasing.class),
          Strings.dispClassName(SoftMaxDecreasingMix.class),
          Strings.dispClassName(UCB1.class),
          Strings.dispClassName(UCB1Tuned.class),
          Strings.dispClassName(UCB2.class) };

  /** Ending of the log files for index selections. */
  public static final String SEL_LOGFILE_ENDING = ".sel.csv";

  /** Ending of the log files for reward notifications. */
  public static final String REWARD_LOGFILE_ENDING = ".rew.dat";

  /** Number of different values for first parameter. */
  public static final int X_DIM = 3;

  /** Number of different values for second parameter. */
  public static final int Y_DIM = 2;

  /** Number of replications that were issued. */
  public static final int REPLICATIONS = 500;

  /**
   * Stores all selections done by the {@link IMinBanditPolicy} instances. First
   * dimension is the problem number, second is the policy, third is the
   * sequence of selections.
   */
  Integer[][][] selections;

  /**
   * Stores all rewards received by the {@link IMinBanditPolicy} instances.
   * First dimension is the problem number, second is the policy, third is the
   * sequence of selections.
   */
  Double[][][] rewards;

  /**
   * Stores the index associated with a certain reward in a manner that is
   * equivalent with {@link ResultsAnalysis#rewards}.
   */
  Integer[][][] rewardIndices;

  /**
   * Stores the reward sums for each parameter combination and policy. First
   * dimension is set-up, second one is policy.
   */
  double[][] rewardSums;

  /**
   * Stores the number of selections that have been conducted. Same dimension
   * semantics as {@link ResultsAnalysis#rewardSums}.
   */
  int[][] selectionSums;

  /**
   * Stores number of received rewards. Same dimension semantics as
   * {@link ResultsAnalysis#rewardSums}.
   */
  int[][] rewRecvSums;

  /** Number of available options. */
  int numOfOptions = 0;

  /**
   * The main method.
   * 
   * @param args
   *          contains source and target directory as parameters
   */
  public static void main(String[] args) {

    if (args.length < 2) {
      throw new RuntimeException(
          "You need  to set source and target directory as parameters!");
    }

    File sourceDirectory = new File(args[0]);
    checkDir(sourceDirectory);

    File targetDirectory = new File(args[1]);
    checkDir(targetDirectory);

    ResultsAnalysis ra = new ResultsAnalysis();
    try {
      ra.readLogFiles(sourceDirectory.getAbsolutePath());
      List<Double[][]> rewardMatrices =
          ra.storeResults(targetDirectory.getAbsolutePath());
      ra.analyse(targetDirectory.getAbsolutePath(), rewardMatrices);
    } catch (Exception ex) {
      ex.printStackTrace();
    }
    System.out.println("Done.");
  }

  /**
   * Checks if given directory exists.
   * 
   * @param sourceDirectory
   *          the source directory
   */
  private static void checkDir(File sourceDirectory) {
    if (!sourceDirectory.exists() || !sourceDirectory.isDirectory()) {
      throw new RuntimeException("The directory '" + sourceDirectory
          + "' does not exist (or is no directory)!");
    }
  }

  /**
   * Reads log file data into the arrays {@link ResultsAnalysis#selections} and
   * {@link ResultsAnalysis#rewards}, after initialising them.
   * 
   * @param sourceDirectory
   *          the source directory
   */
  protected void readLogFiles(String sourceDirectory) throws IOException {

    selections = new Integer[X_DIM * Y_DIM][POLICY_NAMES.length][REPLICATIONS];
    rewardIndices =
        new Integer[X_DIM * Y_DIM][POLICY_NAMES.length][REPLICATIONS];
    rewards = new Double[X_DIM * Y_DIM][POLICY_NAMES.length][REPLICATIONS];
    rewardSums = new double[X_DIM * Y_DIM][POLICY_NAMES.length];
    selectionSums = new int[X_DIM * Y_DIM][POLICY_NAMES.length];
    rewRecvSums = new int[X_DIM * Y_DIM][POLICY_NAMES.length];

    for (int i = 0; i < X_DIM * Y_DIM; i++) {
      for (int j = 0; j < POLICY_NAMES.length; j++) {
        String policy = POLICY_NAMES[j];
        String fileName = sourceDirectory + "/" + policy + (i + 1);
        selectionSums[i][j] = readSelections(selections[i][j], fileName);
        Pair<Integer, Double> results =
            readRewards(rewardIndices[i][j], rewards[i][j], fileName);
        rewRecvSums[i][j] = results.getFirstValue();
        rewardSums[i][j] = results.getSecondValue();
      }
    }
  }

  /**
   * Reads a single file containing selection indices.
   * 
   * @param polSelections
   *          the array in which the selection indices shall be stored
   * @param selFile
   *          the file from which they shall be read
   * @throws IOException
   *           if an error occurs when reading the file
   */
  protected int readSelections(Integer[] polSelections, String fileName)
      throws IOException {
    BufferedReader reader = null;
    try {
      reader =
          new BufferedReader(new FileReader(new File(fileName
              + SEL_LOGFILE_ENDING)));
    } catch (FileNotFoundException f) {
      return 0;
    }
    int rowCount = 0;
    String line = reader.readLine();
    while (line != null && rowCount < REPLICATIONS) {
      polSelections[rowCount] = Integer.parseInt(line);
      numOfOptions = Math.max(numOfOptions, polSelections[rowCount]);
      line = reader.readLine();
      rowCount++;
    }
    reader.close();
    return rowCount;
  }

  /**
   * Reads a single file containing the rewards received by a policy.
   * 
   * @param polRewards
   *          the array in which the policy rewards shall be stored
   * @param fileName
   *          the file from which they shall be read
   * @throws IOException
   */
  protected Pair<Integer, Double> readRewards(Integer[] polIndices,
      Double[] polRewards, String fileName) throws IOException {
    double rewardSum = 0.0;
    BufferedReader reader = null;
    try {
      reader =
          new BufferedReader(new FileReader(new File(fileName
              + REWARD_LOGFILE_ENDING)));
    } catch (FileNotFoundException f) {
      return new Pair<>(0, 0.0);
    }

    int rowCount = 0;
    String line = reader.readLine();
    while (line != null && rowCount < REPLICATIONS) {
      String[] numbers = line.split("\t");
      polIndices[rowCount] = Integer.parseInt(numbers[0]);
      polRewards[rowCount] = Double.parseDouble(numbers[1]);
      rewardSum += polRewards[rowCount];
      line = reader.readLine();
      rowCount++;
    }
    reader.close();
    return new Pair<>(rowCount, rewardSum);
  }

  /**
   * Stores some content to a file.
   * 
   * @param targetFile
   *          the path to the target file
   * @param content
   *          the content to be written into the file
   * @throws IOException
   *           if writing to the file fails
   */
  protected void writeToFile(String targetFile, String content)
      throws IOException {
    try (BufferedWriter writer = new BufferedWriter(new FileWriter(new File(targetFile)))) {
      writer.write(content);
    }
  }

  /**
   * Writes all directly available information into aggregated files.
   * 
   * @param targetDir
   *          the target directory
   * @return list of reward matrices, ordered by policy
   * @throws IOException
   *           if some file output goes wrong
   */
  protected List<Double[][]> writeComparisons(String targetDir)
      throws IOException {

    // Comparisons of selection index
    for (int i = 0; i < X_DIM * Y_DIM; i++) {
      Integer[][] selComp = new Integer[REPLICATIONS][POLICY_NAMES.length];
      for (int j = 0; j < REPLICATIONS; j++) {
        for (int k = 0; k < POLICY_NAMES.length; k++) {
          selComp[j][k] = selections[i][k][j];
        }
      }
      writeToFile(targetDir + "/selection_comp" + (i + 1) + ".csv",
          getHeading(POLICY_NAMES) + Strings.displayMatrix(selComp, ','));
    }

    // Comparisons of rewards
    for (int i = 0; i < X_DIM * Y_DIM; i++) {
      Double[][] rewComp = new Double[REPLICATIONS][POLICY_NAMES.length];
      for (int j = 0; j < REPLICATIONS; j++) {
        for (int k = 0; k < POLICY_NAMES.length; k++) {
          rewComp[j][k] = rewards[i][k][j];
        }
      }
      writeToFile(targetDir + "/reward_comp" + (i + 1) + ".csv",
          getHeading(POLICY_NAMES) + Strings.displayMatrix(rewComp, ','));
    }

    // Reward matrices for policy
    List<Double[][]> rewMatrices = new ArrayList<>();
    for (int i = 0; i < POLICY_NAMES.length; i++) {
      Double[][] rew = new Double[Y_DIM][X_DIM];
      for (int y = 0; y < Y_DIM; y++) {
        for (int x = 0; x < X_DIM; x++) {
          rew[y][x] = rewardSums[getSetupIndex(x, y)][i];
        }
      }
      writeToFile(targetDir + "/rewards_pol_" + POLICY_NAMES[i] + ".csv",
          Strings.displayMatrix(rew, ','));
      rewMatrices.add(rew);
    }

    // Winner matrices
    double[][] winnerRewardMatrix = new double[Y_DIM][X_DIM];
    int[][] winnerIndexMatrix = new int[Y_DIM][X_DIM];
    for (int y = 0; y < Y_DIM; y++) {
      for (int x = 0; x < X_DIM; x++) {
        Pair<Integer, Double> highest = getHighest(rewMatrices, x, y);
        winnerIndexMatrix[y][x] = highest.getFirstValue();
        winnerRewardMatrix[y][x] = highest.getSecondValue();
      }
    }
    writeToFile(targetDir + "/rewards_winner.csv",
        Strings.displayMatrix(winnerRewardMatrix, ','));
    writeToFile(targetDir + "/rewards_winner_pol.csv",
        Strings.displayMatrix(winnerIndexMatrix, ','));
    return rewMatrices;
  }

  /**
   * Conducts advanced result analysis and stores results.
   * 
   * @param targetDir
   *          the target directory
   * @param rewardMatrices
   *          list of reward matrices
   */
  protected void analyse(String targetDir, List<Double[][]> rewardMatrices)
      throws IOException {

    // Options start with 0, so there is one option more than the highest chosen
    // index
    numOfOptions++;

    // Calculate average performance for each option
    double[][][] avgPerf = new double[Y_DIM][X_DIM][numOfOptions];
    int[][] winOpt = new int[Y_DIM][X_DIM];
    int[][] winOptCount = new int[Y_DIM][X_DIM];
    double[][] avgWinOptPerf = new double[Y_DIM][X_DIM];
    int[][] lossOpt = new int[Y_DIM][X_DIM];
    int[][] lossOptCount = new int[Y_DIM][X_DIM];
    double[][] avgLossOptPerf = new double[Y_DIM][X_DIM];
    for (int y = 0; y < Y_DIM; y++) {
      for (int x = 0; x < X_DIM; x++) {

        // Collect performance data per option
        double perf[] = new double[numOfOptions];
        int count[] = new int[numOfOptions];
        int index = getSetupIndex(x, y);
        for (int p = 0; p < POLICY_NAMES.length; p++) {
          registerOptionPerformance(rewardIndices[index][p], rewards[index][p],
              count, perf);
        }

        // Analyse it
        int bestIndex = -1;
        int bestCount = -1;
        double bestAvgPerf = Double.MAX_VALUE;
        int worstIndex = -1;
        int worstCount = -1;
        double worstAvgPerf = Double.MIN_VALUE;
        for (int i = 0; i < numOfOptions; i++) {
          if (count[i] == 0) {
            // If no reward has been received for a given setup, it is likely to
            // have been quarantined (and should hence be ignored)
            avgPerf[y][x][i] = Double.MAX_VALUE;
            continue;
          }
          double p = perf[i] / count[i];
          avgPerf[y][x][i] = p;
          if (p < bestAvgPerf) {
            bestIndex = i;
            bestCount = count[i];
            bestAvgPerf = p;
          }
          if (p > worstAvgPerf) {
            worstIndex = i;
            worstCount = count[i];
            worstAvgPerf = p;
          }
        }
        winOpt[y][x] = bestIndex;
        avgWinOptPerf[y][x] = bestAvgPerf;
        winOptCount[y][x] = bestCount;
        lossOpt[y][x] = worstIndex;
        avgLossOptPerf[y][x] = worstAvgPerf;
        lossOptCount[y][x] = worstCount;
      }
    }

    // Save auxiliary data
    writeToFile(targetDir + "/winner_option.csv",
        Strings.displayMatrix(winOpt, ','));
    writeToFile(targetDir + "/winner_option_avgperf.csv",
        Strings.displayMatrix(avgWinOptPerf, ','));
    writeToFile(targetDir + "/winner_option_counts.csv",
        Strings.displayMatrix(winOptCount, ','));
    writeToFile(targetDir + "/loser_option.csv",
        Strings.displayMatrix(lossOpt, ','));
    writeToFile(targetDir + "/loser_option_avgperf.csv",
        Strings.displayMatrix(avgLossOptPerf, ','));
    writeToFile(targetDir + "/loser_option_counts.csv",
        Strings.displayMatrix(lossOptCount, ','));

    for (int i = 0; i < numOfOptions; i++) {
      double[][] avgPerfOpt = new double[Y_DIM][X_DIM];
      for (int y = 0; y < Y_DIM; y++) {
        for (int x = 0; x < X_DIM; x++) {
          avgPerfOpt[y][x] = avgPerf[y][x][i];
        }
      }
      writeToFile(targetDir + "/option_" + i + "_rewards.csv",
          Strings.displayMatrix(avgPerfOpt, ','));
    }

    int[][] rewCounts =
        hypotheticalRuns(targetDir, avgWinOptPerf, avgLossOptPerf);

    storeRelativeOverheadMatrices(targetDir, rewCounts, avgWinOptPerf,
        rewardMatrices);
  }

  /**
   * Store matrices with relative overhead per policy.
   * 
   * @param targetDir
   *          target directory
   * @param rewCounts
   *          reward counter
   * @param avgWinOptPerf
   *          matrix storing the average optimal performance per set-up
   * @param rewardMatrices
   *          list of reward matrices per policy
   * @throws IOException
   *           if writing to file fails
   */
  protected void storeRelativeOverheadMatrices(String targetDir,
      int[][] rewCounts, double[][] avgWinOptPerf,
      List<Double[][]> rewardMatrices) throws IOException {

    for (int i = 0; i < POLICY_NAMES.length; i++) {
      Double[][] rewardMatrix = rewardMatrices.get(i);
      double[][] relOheadMatrix = new double[Y_DIM][X_DIM];
      for (int y = 0; y < Y_DIM; y++) {
        for (int x = 0; x < X_DIM; x++) {
          relOheadMatrix[y][x] =
              rewardMatrix[y][x] / (rewCounts[y][x] * avgWinOptPerf[y][x]) - 1;
        }
      }
      writeToFile(targetDir + "/rel_overhead_" + POLICY_NAMES[i] + ".csv",
          Strings.displayMatrix(relOheadMatrix, ','));
    }
  }

  /**
   * Store relative overhead to show information on hypothetical runs.
   * 
   * @param targetDir
   *          the target directory
   * @param avgWinOptPerf
   *          the average performance of the best option for setup (y,x)
   * @param avgLossOptPerf
   *          the average performance of the worst option for setup (x,y)
   * @return matrix that stores minimal number of actual rewards per setup
   * @throws IOException
   *           if writing results to files fails
   */
  protected int[][] hypotheticalRuns(String targetDir,
      double[][] avgWinOptPerf, double[][] avgLossOptPerf) throws IOException {

    int[][] rewCount = new int[Y_DIM][X_DIM];

    for (int y = 0; y < Y_DIM; y++) {
      for (int x = 0; x < X_DIM; x++) {
        int setup = getSetupIndex(x, y);
        int bestCaseIndex = POLICY_NAMES.length + 1;
        int worstCaseIndex = POLICY_NAMES.length;
        double bestCasePerf = avgWinOptPerf[y][x];
        double worstCasePerf = avgLossOptPerf[y][x];

        Double[][] hypotheticalRuns =
            new Double[REPLICATIONS][POLICY_NAMES.length + 2];

        // Init
        for (int p = 0; p < POLICY_NAMES.length; p++) {
          hypotheticalRuns[0][p] = rewards[setup][p][0];
        }
        hypotheticalRuns[0][bestCaseIndex] = bestCasePerf;
        hypotheticalRuns[0][worstCaseIndex] = worstCasePerf;

        for (int i = 1; i < REPLICATIONS; i++) {
          // Check if any reward is zero - if so, stop analysis for this setup
          boolean finish = false;
          for (int p = 0; p < POLICY_NAMES.length; p++) {
            if (rewards[setup][p][i] == null) {
              finish = true;
              break;
            }
          }
          if (finish) {
            break;
          }

          // Calculate reward sums for next replication
          for (int p = 0; p < POLICY_NAMES.length; p++) {
            hypotheticalRuns[i][p] =
                hypotheticalRuns[i - 1][p] + rewards[setup][p][i];
          }
          hypotheticalRuns[i][bestCaseIndex] =
              hypotheticalRuns[i - 1][bestCaseIndex] + bestCasePerf;
          hypotheticalRuns[i][worstCaseIndex] =
              hypotheticalRuns[i - 1][worstCaseIndex] + worstCasePerf;
        }

        // Normalize and substract in new matrix, i.e. x/opt - 1
        Double[][] hypotheticalRunsNorm =
            new Double[REPLICATIONS][POLICY_NAMES.length + 2];
        for (int i = 0; i < REPLICATIONS; i++) {
          rewCount[y][x] = i;
          if (hypotheticalRuns[i][0] == null) {
            break;
          }
          double bestCasePerfSum = hypotheticalRuns[i][bestCaseIndex];
          for (int j = 0; j < hypotheticalRuns[i].length; j++) {
            hypotheticalRunsNorm[i][j] =
                (hypotheticalRuns[i][j] / bestCasePerfSum) - 1;
          }
        }

        String[] heading = new String[POLICY_NAMES.length + 2];
        System.arraycopy(POLICY_NAMES, 0, heading, 0, POLICY_NAMES.length);
        heading[bestCaseIndex] = "Optimum";
        heading[worstCaseIndex] = "WorstCase";

        writeToFile(targetDir + "/hyprun_" + (setup + 1) + ".csv",
            getHeading(heading) + Strings.displayMatrix(hypotheticalRuns, ','));
        writeToFile(
            targetDir + "/hyprun_" + (setup + 1) + "_rel_ohverhead.csv",
            getHeading(heading)
                + Strings.displayMatrix(hypotheticalRunsNorm, ','));
      }
    }

    return rewCount;
  }

  /**
   * Iterates through the log-file arrays and fills the arrays counting the
   * selections and the reward per option.
   * 
   * @param rewIndices
   * @param rewValues
   * @param count
   * @param perf
   */
  protected void registerOptionPerformance(Integer[] rewIndices,
      Double[] rewValues, int[] count, double[] perf) {
    for (int i = 0; i < rewIndices.length; i++) {
      if (rewIndices[i] == null) {
        continue;
      }
      count[rewIndices[i]]++;
      perf[rewIndices[i]] += rewValues[i];
    }
  }

  /**
   * Translates x/y index into linear one.
   * 
   * @param x
   *          x parameter
   * @param y
   *          y parameter
   * @return index of that set-up in linear array
   */
  protected int getSetupIndex(int x, int y) {
    int index = x + X_DIM * y;
    return index;
  }

  /**
   * Retrieves index and value from a list of matrices, the index being the
   * matrix with the smallest value at position (x,y), the value being the
   * minimal value (the content of the field (x,y) of the matrix identified by
   * the index).
   * 
   * @param rewMatrices
   *          list of reward matrices
   * @param x
   *          the x coordinate
   * @param y
   *          the y coordinate
   * @return pair (index, value) containing the minimal value at (x,y) and the
   *         index of the associated matrix
   */
  protected Pair<Integer, Double> getHighest(List<Double[][]> rewMatrices,
      int x, int y) {
    int index = -1;
    double reward = Double.MAX_VALUE;
    for (int i = 0; i < rewMatrices.size(); i++) {
      if (rewMatrices.get(i)[y][x] < reward) {
        reward = rewMatrices.get(i)[y][x];
        index = i;
      }
    }
    return new Pair<>(index, reward);
  }

  /**
   * Constructs a comma-separated headline containing the correct order of the
   * policies.
   * 
   * @return
   */
  protected String getHeading(String[] elements) {
    String result = "";
    for (int i = 0; i < elements.length - 1; i++) {
      result += (elements[i] + ",");
    }
    result += elements[elements.length - 1] + "\n";
    return result;
  }

  /**
   * Writes results as files to target directory.
   * 
   * @param targetDir
   *          the target directory
   * @return list of reward matrices per policy
   */
  protected List<Double[][]> storeResults(String targetDir) throws IOException {

    // Write all sums (selections, received rewards, rewards)
    writeToFile(targetDir + "/selection_sums.csv", getHeading(POLICY_NAMES)
        + Strings.displayMatrix(selectionSums, ','));
    writeToFile(targetDir + "/reward_recv_sums.csv", getHeading(POLICY_NAMES)
        + Strings.displayMatrix(rewRecvSums, ','));
    writeToFile(targetDir + "/rewards.csv",
        getHeading(POLICY_NAMES) + Strings.displayMatrix(rewardSums, ','));
    List<Double[][]> rewMatrices = writeComparisons(targetDir);
    return rewMatrices;
  }
}
