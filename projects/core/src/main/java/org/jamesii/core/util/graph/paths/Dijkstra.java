/*
 * The general modelling and simulation framework JAMES II.
 * Copyright by the University of Rostock.
 * 
 * LICENCE: JAMESLIC
 */
package org.jamesii.core.util.graph.paths;

import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import org.jamesii.SimSystem;
import org.jamesii.core.util.eventset.IBasicEventQueue;
import org.jamesii.core.util.eventset.plugintype.AbstractEventQueueFactory;
import org.jamesii.core.util.eventset.plugintype.EventQueueFactory;
import org.jamesii.core.util.graph.IGraph;
import org.jamesii.core.util.graph.LabeledEdge;

/**
 * Implementation of Dijkstra algorithm for the shortest paths problem.
 * 
 * @param <V>
 *          the type of vertices
 * 
 * @author Jan Himmelspach
 * @version 1.0
 */
public class Dijkstra<V> extends ShortestPath<V> {

  /**
   * The priority queue to be used in the algorithm.
   */
  private EventQueueFactory cqf = null;

  /**
   * Map that stores the optimal paths: vertex => previous vertex on optimal
   * path.
   */
  private Map<V, V> optimalPaths;

  /**
   * Create a new instance of the algorithm.
   */
  public Dijkstra() {
    super();
  }

  /**
   * Create a new instance of the algorithm which will use an instance of a
   * priority queue generated by the factory passed.
   * 
   * @param eqf
   *          the event / priority queue factory to be used
   */
  public Dijkstra(EventQueueFactory eqf) {
    super();
    cqf = eqf;
  }

  /**
   * Computes the shortest paths in the graph to the given node by using the
   * Dijkstra shortest path algorithm <code>
   * 1   function Dijkstra(G, w, s)<br/>
   * 2      for each vertex v in V[G]                        // Initialization<br/>
   * 3         do d[v] := infinity<br/>
   * 4            previous[v] := undefined<br/>
   * 5      d[s] := 0<br/>
   * 6      S := empty set<br/>
   * 7      Q := set of all vertices<br/>
   * 8      while Q is not an empty set<br/>
   * 9         do u := Extract-Min(Q)<br/>
   * 10           S := S union {u}<br/>
   * 11           for each edge (u,v) outgoing from u<br/>
   * 12              do if d[v] > d[u] + w(u,v)             // Relax (u,v)<br/>
   * 13                 then d[v] := d[u] + w(u,v)<br/>
   * 14                    previous[v] := u<br/>
   * 15                    Q := Update(Q)<br/>
   * </code>.
   * 
   * @param graph
   *          the graph
   * @param startVertex
   *          the start vertex
   * 
   * @return length of paths from each node in the graph to the given node
   */
  @Override
  public Map<V, Double> compute(
      IGraph<V, ? extends LabeledEdge<V, Double>> graph, V startVertex) {

    IBasicEventQueue<V, Double> vertexQueue = createPriorityQueue();
    optimalPaths = initPreviousMap(graph);
    Map<V, Double> distances = initDistanceMap(graph, startVertex);

    // enqueue all vertices into the priority queue
    for (Map.Entry<V, Double> e : distances.entrySet()) {
      vertexQueue.enqueue(e.getKey(), e.getValue());
    }

    // while the queue is not empty (line 8 in pseudo code do)
    while (!vertexQueue.isEmpty()) {
      V u = vertexQueue.dequeue().getEvent();
      Collection<? extends LabeledEdge<V, Double>> edges = graph.getEdges(u);
      if (graph.isDirected()) {
        filterIncomingEdges(u, edges);
      }

      for (LabeledEdge<V, Double> e : edges) {
        V v =
            u.equals(e.getFirstVertex()) ? e.getSecondVertex() : e
                .getFirstVertex();

        // if distance d[v] > d[u] + w(u,v) (weight of edge) then
        if (distances.get(v) > distances.get(u) + e.getLabel()) {

          // replace d[v] by this value
          distances.put(v, distances.get(u) + e.getLabel());

          // set the prev pointer of node v to u
          optimalPaths.put(v, u);

          // update set Q (Q := update(Q) updates the weight field of the
          // current vertex in the vertex set Q.)
          vertexQueue.enqueue(v, distances.get(v));
        }

      }
    }

    return distances;
  }

  /**
   * Filters incoming edges (as only outgoing edges can be used to construct a
   * path).
   * 
   * @param firstVertex
   *          the u
   * @param edges
   *          the edges
   */
  private void filterIncomingEdges(V firstVertex,
      Collection<? extends LabeledEdge<V, Double>> edges) {
    Iterator<? extends LabeledEdge<V, Double>> it = edges.iterator();
    while (it.hasNext()) {
      if (it.next().getFirstVertex() != firstVertex) {
        it.remove();
      }
    }
  }

  /**
   * Initializes the distance map.
   * 
   * @param graph
   *          the graph
   * @param startNode
   *          the start node
   * @return the map of distances (all set to infinity)
   */
  private Map<V, Double> initDistanceMap(
      IGraph<V, ? extends LabeledEdge<V, Double>> graph, V startNode) {
    Map<V, Double> distances = new HashMap<>();
    for (V v : graph.getVertices()) {
      distances.put(v, Double.POSITIVE_INFINITY);
    }
    // distance to the starting node is 0
    distances.put(startNode, Double.valueOf(0.));
    return distances;
  }

  /**
   * Initializes the map to store the 'previous' vertices.
   * 
   * @param graph
   *          the graph
   * @return the map vertex => previous vertex
   */
  private Map<V, V> initPreviousMap(
      IGraph<V, ? extends LabeledEdge<V, Double>> graph) {
    Map<V, V> previous = new HashMap<>();
    for (V v : graph.getVertices()) {
      previous.put(v, null);
    }
    return previous;
  }

  /**
   * Creates the priority queue. As queue any
   * {@link org.jamesii.core.util.eventset.IEventQueue} instance can be used.
   * 
   * @return the priority queue
   */
  private IBasicEventQueue<V, Double> createPriorityQueue() {
    EventQueueFactory eqf;
    // if no event queue has been pre-selected, fetch one from the registry
    if (cqf == null) {
      eqf =
          SimSystem.getRegistry().getFactory(AbstractEventQueueFactory.class,
              null);
    } else {
      // use the pre-selected queue
      eqf = cqf;
    }

    return eqf.createDirect(null);
  }

  /**
   * Find the vertex with the min dist cost.
   * 
   * @param from
   *          the from
   * @param d
   *          the d
   * 
   * @return the integer
   */
  protected Integer extractMin(Map<Integer, Object> from, double[] d) {
    Iterator<Integer> it = from.keySet().iterator();
    double min = Double.POSITIVE_INFINITY;
    int ind = -1;
    while (it.hasNext()) {
      Integer i = it.next();
      if (d[i] < min) {
        ind = i;
        min = d[i];
      }
    }
    if (ind == -1) {
      ind = 0;
    }
    return ind;
  }

  /**
   * Gets the optimal paths. Has to be called AFTER
   * {@link Dijkstra#compute(IGraph, Object)} has been called.
   * 
   * @return the mapping that stores the optimal paths
   */
  public Map<V, V> getOptimalPaths() {
    return optimalPaths;
  }
}
